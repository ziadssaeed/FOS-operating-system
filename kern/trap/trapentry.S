/* See COPYRIGHT for copyright information. */

#include <inc/mmu.h>
#include <inc/memlayout.h>
#include <inc/trap.h>
#include <kern/cpu/picirq.h>



###################################################################
# exceptions/interrupts
###################################################################

/* The TRAPHANDLER macro defines a globally-visible function for handling
 * a trap.  It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 */
#define TRAPHANDLER(name, num)										\
	.globl name;			/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */			\
	.align 2;				/* align function definition */			\
	name:					/* function starts here */				\
	pushl $(num); 			/* pushes a trap 'num' into stack */	\
	jmp _alltraps			/* complete push other regs & call C */

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)			\
	.globl name;							\
	.type name, @function;					\
	.align 2;								\
	name:									\
	pushl $0;								\
	pushl $(num);							\
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ



/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
push 	%es
pushal

mov 	$(GD_KD), %ax
mov 	%ax,%ds
mov 	%ax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
call 	trap

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
.globl trapret
trapret:
popal
pop 	%es
pop 	%ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
iret


